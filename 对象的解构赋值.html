<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <script>
        /* 
        let{key1,key2} = {key1:val1,key2:val2}
        在声明的时候使用块声明，块中放对象的key值，这里的key值一定要和解构对象的key值名字一致
        如果取别名，使用：新定义的名字即可：
        let {key1:k,key2} = {key1:val1,key2:val2}
    
        此时的key1已经访问不到了，要访问就报错，只能访问k, k就代编key1，名字跟声明变量规则一致
    
        如果加了：不报错，那么可以先解构一次，再重命名
        let {
            f,  //先把f解构出来，这样就可以访问f了
            f:x
        } = {
            f:{
                name:'11',
                age:22
            }
        }
         */
        let objhdjksdjks = {
            type: "sug",
            sa: "s_2",
            q: "啦啦啦啦啦",
            s: "哈哈哈哈哈哈"
        }

        // let {type:t,q,s} = objhdjksdjks;
        // console.log(type,q,s);
        // console.log(t);

        // console.log(objhdjksdjks.type);
        // console.log(objhdjksdjks.q);
        // console.log(objhdjksdjks.s);

        // console.dir(console);

        // let {log,dir} = console;

        // log(1);

        let obj = {
            p: [
                'Hello',
                {
                    y: 'World',
                    z: {
                        x: [
                            {
                                j: 0
                            }
                        ]
                    }
                }
            ]
        };
        let { p: [x, { y, z: { x: [{ j }] } }] } = obj

        console.log(j);


        // const node = {
        //     loc: {
        //         start: {
        //             line: 1,
        //             column: 5
        //         }
        //     }
        // };

        // let { loc, loc: { start }, loc: { start: { line }} } = node;

        // console.log(line);


        let {
            f,
            f: x
        } = {
            f: {
                name: '11',
                age: 22
            }
        }

        // console.log(f)


        // let obj = {};
        // let arr = [];
        //foo->123  -> obj.prop = 123 
        // ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

        // console.log(obj,arr);
        // obj.prop = {}.foo;

        // var {x, y = 5} = {x: 1};
        // console.log(x,y);

        // let {value:val} = input
        // function fn({age:{b}}){
        //     // obj.age.b
        //     console.log(b);
        // }
        // fn({name:'haha',age:{s:1,b:2}})
        // function move({x, y} = { x: 0, y: 0 }) {
        //     return [x, y];
        // }
        /*
        传了对象那么就按照传的对象来解析，不会按照默认的来解析 
        */
        const { log } = console;
        // log(move({x: 3, y: 8}));  //3,8
        // log( move( {x: 3} ));   //3,undefined
        // log( move({}));    //undefined,undefined
        // log(move());    //0,0


        log([1, undefined, 3].map((item = 'yes') => item));
    </script>
</body>

</html>