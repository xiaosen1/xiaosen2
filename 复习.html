<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
    /* 
    obj ={
        name:'xx'
        age:19
    }
    单例模式：单独的实例
    高级单例模式：

        A同学
        let obj = (function(){
            // let obj = {}
            function sum(){

            }
            return {
                sum:sum
            }
        })()

        B同学
        let obj = (function(i){
            function sum(){}
            obj.sum()
            return{

            }
        })(i)

        

       封闭空间不是闭包，而闭包有封闭空间的功能
    工厂模式：
            function fn(){
                let obj={}
                obj.name = name
                obj.age = age
                return obj
            }

    面向对象（谁来做这件事）：
            封装，继承，多态，面向对象的特征

            封装就是归类的过程

            ** 换了一种编程方式 **：把具有相同特征特性的代码归为一类（类）
            把描述这个类的特性（共有属性，方法）挂在这个类的原型下的一种
            编程方式

    面向过程：
            思考如何把它实现

    new： 函数的一元运算符，只能运算函数

            1. this变成了实例
            2.默认return实例，如果手动设置了返回值，如果是原始类型的那么还是实例，如果是引用类型的那么返回的就是引用类型
            3.加不加括号都能执行函数，括号主要是为了传参
            4.首字母大写

    原型：
        当声明函数的时候，函数天生自带的一个属性prototype(key)  ：{}(val)

        prototype下的方法或者属性只能同通过两种方式使用：
            1. 给自己的实例化对象使用 new fn().a
            2. 直接使用fn.prototype.a
        
    原型链：
            实例化对象上都有一个叫做_proto_的属性，它的值全等于构造函数的原型

            如果某个原型下没有想要的属性或者方法，那么还会通过这个原型下的原型链继续查找，直到找到object.prototype为止
            因为Object.prototype._proto_为null

            {
                prototype:{

                }
            }



     */


     function fn(){

     }
    //  Object.prototype.a = 20
    //  fn.prototype.a = function(){
    //      console.log(this)
    //  }

    //  console.dir(new fn()._proto_ === fn.prototype)
    //  console.log(fn.prototype)
    //  console.log(new fn()._proto_.a)
    //  new fn()._proto_.a()
    //  new fn().a()  
    //  console.log(fn)

    /* 
    实例下的.a  ->实例._proto_ - > 构造函数的原型（fn.prototype）
    fn.prototype._proto_->Object.prototype->

    Object.prototype._proto_=null

    fn.prototype={
        _proto_:Object.prototype
    }

    内置类：浏览器自带的类

            所有的类型都是构造函数构造出来的
                string  '', "", ``,new String

                object  {} , new Object()

                function   new Function   
                
                []

     */

    //  console.log(new fn().a)  // undefined
    //  console.log(new String('123'))  // String '123'
    //  console.log(new fn().a)
    //  console.dir(typeof Object)
    //  console.log(typeof new Function())
    //  let fn1 = new Function('a,b','return(a+b)')
    //  console.log(fn1(1,2))
    //  console.log(typeof Function)
    //  console.log(Object instanceof Object)
    //  console.dir(Function)

    //  Function.prototype.a =10
    //  function ff(){

    //  }
    //  ff.prototype.a = 20
    //  //console.log(new ff().a)
    //  console.log(ff.a)

    //  console.dir(ff)

    /* 
    ff.a - > ff._proto_ -> Function.prototype
     */


    /* 
    fn.a fn._proto_ - >Function.prototype

    Function.a Function._proto_ ->
    Function.prototype
     */
     console.log(Function.a)
    </script>
</body>
</html>